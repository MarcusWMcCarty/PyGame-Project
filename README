-Planning
    In Alien Invasion, the player controls a rocket ship that appears at the bottom center of the screen. 
    The player can move the ship right and left using the arrow keys and shoot bullets using the spacebar. 
    When the game begins, a fleet of aliens fill the sky and moves across and down the screen. 
    The player shoots and destroys the aliens.
    If the player shoots all the aliens, a new fleet appears that moves fasetr than the previous fleet. 
    If any alien hits the players ship or reaches the bottom of the screen, the player loses a ship.
    If the player loses three ships, the game ends. 

Starting the Game Project:
    Starts as a class called AlienInvasion.
    Sets up Display
    Sets up Surface, a surface in pygame is a part of the screen where a game element can be displayed.

Setting Background Color:
    Fill the background using the fill() method, which acts as a surface and only takes one argument, a color.

Creating a Settings Class
    Created a settings class to store settings varibales in one place. this approach works better for adjusting individual settings. 

Adding the Ship Imaage:
    Load the image and use pygame blit() method to draw it. 
    Postition the ship image into the mid bottom and called on it in the alien_invasion file to make it appear at te bottom of the screen.

Refactoring the _check_events() and _update_screen() methods
    The _check_events() Method 
        We’ll start by moving the code that manages events to a separate function
        called check_events(). This will simplify run_game() and isolate the event management loop. 
        Isolating the event loop allows you to manage events separately from other aspects of the game, like updating the screen.

Piltoing the Ship
    give the player the ability to move the ship right and left. To do this,
    we’ll write code that responds when the player presses the right or left
    arrow key
    
Moving the Ship
    First we set up a KEYDOWN event that makes the ship move everytime a player presses the right arrow key one spacebar
    Then we must allow for continuous movement.
        When the player holds down the right arrow key, we want the ship to
        continue moving right until the player releases the key. We’ll have our
        game detect a pygame.KEYUP event so we’ll know when the right arrow key is
        released; then we’ll use the KEYDOWN and KEYUP events together with a flag
        called moving_right to implement continuous motion.

        When the ship is motionless, the moving_right flag will be False. When the
        right arrow key is pressed, we’ll set the flag to True, and when it’s released,
        we’ll set the flag to False again.

        The Ship class controls all attributes of the ship, so we’ll give it an attribute called moving_right and an update() method to check the status of the
        moving_right flag. The update() method will change the position of the ship if
        the flag is set to True. We’ll call this method any time we want to update the
        position of the ship

Adjusting the Ships Speed
    Currently, the ship moves one pixel per cycle through the while loop, but
    we can take finer control of the ship’s speed by adding a ship_speed_factor
    attribute to the Settings class. We’ll use this attribute to determine how far
    to move the ship on each pass through the loop

    Then we Limit the ships speed by modyfying the supdate() method in ship.

Refactoring _check_events()
    break down into two more methods: one that handles KEYDOWN events and another that handles KEYUP events

Pressing Q to Quit
    Keyboard shortuct "Q" to quit game

Adding the Bullet Settings
    Update setting.py with new values that well need for bullet class

Creating the Bullet Class
    First we used a method to define the bullets settings and midtop attributes
    Then we must create another method to update and draw the bullet

Storing Bullets in a Group
    Now that we have a Bullet class and the necessary settings defined, we can
    write code to fire a bullet each time the player presses the spacebar. First,
    we’ll create a group in alien_invasion.py to store all the live bullets so we
    can manage the bullets that have already been fired. This group will be an
    instance of the class pygame.sprite.Group, which behaves like a list with some
    extra functionality that’s helpful when building games. We’ll use this group
    to draw bullets to the screen on each pass through the main loop and to
    update each bullet’s position:

Firing Bullets
    Import Bullet from Bullet
    elif event key for spacebar
    def _fire_bullet(self) to fire bullets

Deleting Old Bullets
    Bullets currently dont actually disappear when they clear the top screen which makes them consume memory and processing poiwer.
    We need to get rid of these old bullets, or the game will slow down from
    doing so much unnecessary work. To do this, we need to detect when the
    bottom value of a bullet’s rect has a value of 0, which indicates the bullet has
    passed off the top of the screen:

Limiting Bullets    
    if len(self.bullets) < self.settings.bullets_allowed:

    When the spacebar is pressed, we check the length of bullets. If
    len(bullets) is less than three, we create a new bullet. But if three bullets
    are already active, nothing happens when the spacebar is pressed. If you run
    the game now, you should be able to fire bullets only in groups of three.

Creating the _update_bullets() Method
    moving the bullet managment code to a seperate method to keep file more organized.


CHAPTER 13 - Aliens 
    Placing one alien on the screen is like placing a ship on the screen.
    The behavior of each alien is controlled by a class called Alien, which
    we’ll structure like the Ship class

Drawing the Alien fleet
    Determining How Many Aliens fit in a row
        1. Find out how much horizontal space we have
            To figure out how many aliens fit in a row, let’s look at how much horizontal
            space we have. The screen width is stored in ai_settings.screen_width, but we
            need an empty margin on either side of the screen. We’ll make this margin
            the width of one alien. Because we have two margins, the available space for
            aliens is the screen width minus two alien widths:
                available_space_x = ai_settings.screen_width – (2 * alien_width)

        2. Spacing Between Aliens
            number_aliens_x = available_space_x / (2 * alien_width)

            The space needed to display one alien is twice its width: one width
            for the alien and one width for the empty space to its right. To find the
            number of aliens that fit across the screen, we divide the available space by
            two times the width of an alien:


